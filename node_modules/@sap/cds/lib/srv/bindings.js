
const cds = require ('..'), DEBUG = cds.debug('serve|bindings',{label:'cds'})
const { readFile, readFileSync, writeFile, writeFileSync } = require ('fs')
const [ read, write ] = [ readFile, writeFile ].map(require('util').promisify)
const registry = '~/.cds-services.json'
const filename = registry.replace(/^~/, require('os').homedir())

/** TODO: Add documentation */
module.exports = class Bindings {

  static get registry(){ return registry }

  static then(r,e) {
    const LOG = cds.log('cds.serve', { prefix:'cds' })
    const bindings = new Bindings
    cds.prependOnceListener ('connect', ()=> LOG._info && LOG.info ('connect using bindings from:', { registry }))
    cds.once('listening', ({url})=> bindings.export (cds.service.providers, url))
    return bindings.import() .then (r,e)
  }

  constructor() {
    this.provides = {}
    this.servers = {}
  }

  async load (sync) {
    DEBUG?.('reading bindings from:', registry)
    try {
      let {cds} = JSON.parse (sync ? readFileSync (filename) : await read (filename))
      Object.assign (this,cds)
    }
    catch { /* ignored */ }
    return this
  }
  async store (sync) {
    DEBUG?.('writing bindings to:', registry)
    const json = JSON.stringify ({cds:this},null,'  ')
    return sync ? writeFileSync (filename, json) : write (filename, json)
  }

  async import() {
    const required = cds.requires; if (!required) return this
    const provided = (await this.load()) .provides
    for (let each in required) {
      const req = required[each]; if (typeof req !== 'object') continue
      const bound = provided [req.service||each]
      if (bound) {
        Object.assign (req.credentials || (req.credentials = {}), bound.credentials)
        // REVISIT: temporary fix to inherit kind as well for mocked odata services
        // otherwise mocking with two services does not work for kind:odata-v2
        if (req.kind === 'odata-v2' || req.kind === 'odata-v4') req.kind = 'odata'
      }
    }
    return this
  }

  async export (services, url) {
    this.cleanup (url)
    const { servers, provides } = this, { pid } = process
    // register our server
    servers[pid] = {
      root: 'file://' + cds.root,
      url
    }
    // register our services
    for (let each of services) {
      // if (each.name in cds.env.requires)  continue
      const options = each.options || {}
      provides[each.name] = {
        kind: options.to || 'odata',
        credentials: {
          ...options.credentials,
          url: url + each.path
        },
        server: pid
      }
    }
    process.on ('exit', ()=>this.purge())
    return this.store()
  }

  purge() {
    this.load(true)
    DEBUG?.('purging bindings from:', registry)
    this.cleanup()
    this.store(true)
  }

  /**
   * Remove all services served by this server or at the given url.
   */
  cleanup (url) {
    const { servers, provides } = this, { pid } = process
    for (let [key,srv] of Object.entries (provides))
      if (srv.server === pid || url && srv.credentials?.url?.startsWith(url)) delete provides [key]
    delete servers [pid]
    return this
  }
}

const {NODE_ENV} = process.env
if (NODE_ENV === 'test' || global.it || cds.env.no_bindings) {
  module['exports'] = { then: (r) => r() }
}
/* eslint no-console:off */
